// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "encode_value_generated.h"
#include "enums_generated.h"

namespace dexkit {
namespace schema {

struct ClassMeta;
struct ClassMetaBuilder;

struct ClassMetaArrayHolder;
struct ClassMetaArrayHolderBuilder;

struct MethodMeta;
struct MethodMetaBuilder;

struct MethodMetaArrayHolder;
struct MethodMetaArrayHolderBuilder;

struct FieldMeta;
struct FieldMetaBuilder;

struct FieldMetaArrayHolder;
struct FieldMetaArrayHolderBuilder;

struct AnnotationEncodeValueMeta;
struct AnnotationEncodeValueMetaBuilder;

struct AnnotationEncodeArray;
struct AnnotationEncodeArrayBuilder;

struct AnnotationElementMeta;
struct AnnotationElementMetaBuilder;

struct AnnotationMeta;
struct AnnotationMetaBuilder;

struct AnnotationMetaArrayHolder;
struct AnnotationMetaArrayHolderBuilder;

struct ParametersAnnotationMetaArrayHoler;
struct ParametersAnnotationMetaArrayHolerBuilder;

struct BatchClassMeta;
struct BatchClassMetaBuilder;

struct BatchClassMetaArrayHolder;
struct BatchClassMetaArrayHolderBuilder;

struct BatchMethodMeta;
struct BatchMethodMetaBuilder;

struct BatchMethodMetaArrayHolder;
struct BatchMethodMetaArrayHolderBuilder;

struct UsingFieldMeta;
struct UsingFieldMetaBuilder;

struct UsingFieldMetaArrayHolder;
struct UsingFieldMetaArrayHolderBuilder;

enum class AnnotationEncodeValue : uint8_t {
  NONE = 0,
  EncodeValueByte = 1,
  EncodeValueShort = 2,
  EncodeValueChar = 3,
  EncodeValueInt = 4,
  EncodeValueLong = 5,
  EncodeValueFloat = 6,
  EncodeValueDouble = 7,
  EncodeValueString = 8,
  ClassMeta = 9,
  MethodMeta = 10,
  FieldMeta = 11,
  AnnotationEncodeArray = 12,
  AnnotationMeta = 13,
  EncodeValueNull = 14,
  EncodeValueBoolean = 15
};

inline const AnnotationEncodeValue (&EnumValuesAnnotationEncodeValue())[16] {
  static const AnnotationEncodeValue values[] = {
    AnnotationEncodeValue::NONE,
    AnnotationEncodeValue::EncodeValueByte,
    AnnotationEncodeValue::EncodeValueShort,
    AnnotationEncodeValue::EncodeValueChar,
    AnnotationEncodeValue::EncodeValueInt,
    AnnotationEncodeValue::EncodeValueLong,
    AnnotationEncodeValue::EncodeValueFloat,
    AnnotationEncodeValue::EncodeValueDouble,
    AnnotationEncodeValue::EncodeValueString,
    AnnotationEncodeValue::ClassMeta,
    AnnotationEncodeValue::MethodMeta,
    AnnotationEncodeValue::FieldMeta,
    AnnotationEncodeValue::AnnotationEncodeArray,
    AnnotationEncodeValue::AnnotationMeta,
    AnnotationEncodeValue::EncodeValueNull,
    AnnotationEncodeValue::EncodeValueBoolean
  };
  return values;
}

inline const char * const *EnumNamesAnnotationEncodeValue() {
  static const char * const names[17] = {
    "NONE",
    "EncodeValueByte",
    "EncodeValueShort",
    "EncodeValueChar",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    "EncodeValueString",
    "ClassMeta",
    "MethodMeta",
    "FieldMeta",
    "AnnotationEncodeArray",
    "AnnotationMeta",
    "EncodeValueNull",
    "EncodeValueBoolean",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationEncodeValue(AnnotationEncodeValue e) {
  if (::flatbuffers::IsOutRange(e, AnnotationEncodeValue::NONE, AnnotationEncodeValue::EncodeValueBoolean)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationEncodeValue()[index];
}

template<typename T> struct AnnotationEncodeValueTraits {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::NONE;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueByte> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueByte;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueShort> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueShort;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueChar> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueChar;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueInt> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueInt;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueLong> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueLong;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueFloat> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueFloat;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueDouble> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueDouble;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueString> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueString;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::ClassMeta> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::ClassMeta;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::MethodMeta> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::MethodMeta;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::FieldMeta> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::FieldMeta;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::AnnotationEncodeArray> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::AnnotationEncodeArray;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::AnnotationMeta> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::AnnotationMeta;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueNull> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueNull;
};

template<> struct AnnotationEncodeValueTraits<dexkit::schema::EncodeValueBoolean> {
  static const AnnotationEncodeValue enum_value = AnnotationEncodeValue::EncodeValueBoolean;
};

bool VerifyAnnotationEncodeValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationEncodeValue type);
bool VerifyAnnotationEncodeValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationEncodeValue> *types);

struct ClassMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_SOURCE_FILE = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_SUPER_CLASS = 14,
    VT_INTERFACES = 16,
    VT_METHODS = 18,
    VT_FIELDS = 20
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t dex_id() const {
    return GetField<uint32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::String *source_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FILE);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  uint32_t super_class() const {
    return GetField<uint32_t>(VT_SUPER_CLASS, 0);
  }
  const ::flatbuffers::Vector<int32_t> *interfaces() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERFACES);
  }
  const ::flatbuffers::Vector<int32_t> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<int32_t> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_SOURCE_FILE) &&
           verifier.VerifyString(source_file()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<uint32_t>(verifier, VT_SUPER_CLASS, 4) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyVector(interfaces()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.EndTable();
  }
};

struct ClassMetaBuilder {
  typedef ClassMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_ID, id, 0);
  }
  void add_dex_id(uint32_t dex_id) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_source_file(::flatbuffers::Offset<::flatbuffers::String> source_file) {
    fbb_.AddOffset(ClassMeta::VT_SOURCE_FILE, source_file);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(ClassMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_super_class(uint32_t super_class) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_SUPER_CLASS, super_class, 0);
  }
  void add_interfaces(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces) {
    fbb_.AddOffset(ClassMeta::VT_INTERFACES, interfaces);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods) {
    fbb_.AddOffset(ClassMeta::VT_METHODS, methods);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields) {
    fbb_.AddOffset(ClassMeta::VT_FIELDS, fields);
  }
  explicit ClassMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_file = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    uint32_t super_class = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields = 0) {
  ClassMetaBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_methods(methods);
  builder_.add_interfaces(interfaces);
  builder_.add_super_class(super_class);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_source_file(source_file);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ClassMeta::Traits {
  using type = ClassMeta;
  static auto constexpr Create = CreateClassMeta;
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    const char *source_file = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    uint32_t super_class = 0,
    const std::vector<int32_t> *interfaces = nullptr,
    const std::vector<int32_t> *methods = nullptr,
    const std::vector<int32_t> *fields = nullptr) {
  auto source_file__ = source_file ? _fbb.CreateString(source_file) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto interfaces__ = interfaces ? _fbb.CreateVector<int32_t>(*interfaces) : 0;
  auto methods__ = methods ? _fbb.CreateVector<int32_t>(*methods) : 0;
  auto fields__ = fields ? _fbb.CreateVector<int32_t>(*fields) : 0;
  return dexkit::schema::CreateClassMeta(
      _fbb,
      id,
      dex_id,
      source_file__,
      access_flags,
      dex_descriptor__,
      super_class,
      interfaces__,
      methods__,
      fields__);
}

struct ClassMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *>(VT_CLASSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASSES) &&
           verifier.VerifyVector(classes()) &&
           verifier.VerifyVectorOfTables(classes()) &&
           verifier.EndTable();
  }
};

struct ClassMetaArrayHolderBuilder {
  typedef ClassMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_classes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes) {
    fbb_.AddOffset(ClassMetaArrayHolder::VT_CLASSES, classes);
  }
  explicit ClassMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMetaArrayHolder> CreateClassMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes = 0) {
  ClassMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_classes(classes);
  return builder_.Finish();
}

struct ClassMetaArrayHolder::Traits {
  using type = ClassMetaArrayHolder;
  static auto constexpr Create = CreateClassMetaArrayHolder;
};

inline ::flatbuffers::Offset<ClassMetaArrayHolder> CreateClassMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes = nullptr) {
  auto classes__ = classes ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>(*classes) : 0;
  return dexkit::schema::CreateClassMetaArrayHolder(
      _fbb,
      classes__);
}

struct MethodMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_RETURN_TYPE = 14,
    VT_PARAMETER_TYPES = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t dex_id() const {
    return GetField<uint32_t>(VT_DEX_ID, 0);
  }
  uint32_t class_id() const {
    return GetField<uint32_t>(VT_CLASS_ID, 0);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  uint32_t return_type() const {
    return GetField<uint32_t>(VT_RETURN_TYPE, 0);
  }
  const ::flatbuffers::Vector<int32_t> *parameter_types() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMETER_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<uint32_t>(verifier, VT_RETURN_TYPE, 4) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPES) &&
           verifier.VerifyVector(parameter_types()) &&
           verifier.EndTable();
  }
};

struct MethodMetaBuilder {
  typedef MethodMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_ID, id, 0);
  }
  void add_dex_id(uint32_t dex_id) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(uint32_t class_id) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(MethodMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_return_type(uint32_t return_type) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_RETURN_TYPE, return_type, 0);
  }
  void add_parameter_types(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types) {
    fbb_.AddOffset(MethodMeta::VT_PARAMETER_TYPES, parameter_types);
  }
  explicit MethodMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    uint32_t class_id = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    uint32_t return_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types = 0) {
  MethodMetaBuilder builder_(_fbb);
  builder_.add_parameter_types(parameter_types);
  builder_.add_return_type(return_type);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodMeta::Traits {
  using type = MethodMeta;
  static auto constexpr Create = CreateMethodMeta;
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    uint32_t class_id = 0,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    uint32_t return_type = 0,
    const std::vector<int32_t> *parameter_types = nullptr) {
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto parameter_types__ = parameter_types ? _fbb.CreateVector<int32_t>(*parameter_types) : 0;
  return dexkit::schema::CreateMethodMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      access_flags,
      dex_descriptor__,
      return_type,
      parameter_types__);
}

struct MethodMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *>(VT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct MethodMetaArrayHolderBuilder {
  typedef MethodMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods) {
    fbb_.AddOffset(MethodMetaArrayHolder::VT_METHODS, methods);
  }
  explicit MethodMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMetaArrayHolder> CreateMethodMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods = 0) {
  MethodMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_methods(methods);
  return builder_.Finish();
}

struct MethodMetaArrayHolder::Traits {
  using type = MethodMetaArrayHolder;
  static auto constexpr Create = CreateMethodMetaArrayHolder;
};

inline ::flatbuffers::Offset<MethodMetaArrayHolder> CreateMethodMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods = nullptr) {
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>(*methods) : 0;
  return dexkit::schema::CreateMethodMetaArrayHolder(
      _fbb,
      methods__);
}

struct FieldMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_TYPE_ID = 14
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t dex_id() const {
    return GetField<uint32_t>(VT_DEX_ID, 0);
  }
  uint32_t class_id() const {
    return GetField<uint32_t>(VT_CLASS_ID, 0);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  uint32_t type_id() const {
    return GetField<uint32_t>(VT_TYPE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE_ID, 4) &&
           verifier.EndTable();
  }
};

struct FieldMetaBuilder {
  typedef FieldMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_ID, id, 0);
  }
  void add_dex_id(uint32_t dex_id) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(uint32_t class_id) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(FieldMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_type_id(uint32_t type_id) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_TYPE_ID, type_id, 0);
  }
  explicit FieldMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    uint32_t class_id = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    uint32_t type_id = 0) {
  FieldMetaBuilder builder_(_fbb);
  builder_.add_type_id(type_id);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct FieldMeta::Traits {
  using type = FieldMeta;
  static auto constexpr Create = CreateFieldMeta;
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t dex_id = 0,
    uint32_t class_id = 0,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    uint32_t type_id = 0) {
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  return dexkit::schema::CreateFieldMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      access_flags,
      dex_descriptor__,
      type_id);
}

struct FieldMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMeta>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMeta>> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct FieldMetaArrayHolderBuilder {
  typedef FieldMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMeta>>> fields) {
    fbb_.AddOffset(FieldMetaArrayHolder::VT_FIELDS, fields);
  }
  explicit FieldMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMetaArrayHolder> CreateFieldMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMeta>>> fields = 0) {
  FieldMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_fields(fields);
  return builder_.Finish();
}

struct FieldMetaArrayHolder::Traits {
  using type = FieldMetaArrayHolder;
  static auto constexpr Create = CreateFieldMetaArrayHolder;
};

inline ::flatbuffers::Offset<FieldMetaArrayHolder> CreateFieldMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::FieldMeta>> *fields = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::FieldMeta>>(*fields) : 0;
  return dexkit::schema::CreateFieldMetaArrayHolder(
      _fbb,
      fields__);
}

struct AnnotationEncodeValueMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationEncodeValueMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  dexkit::schema::AnnotationEncodeValueType type() const {
    return static_cast<dexkit::schema::AnnotationEncodeValueType>(GetField<int8_t>(VT_TYPE, 0));
  }
  dexkit::schema::AnnotationEncodeValue value_type() const {
    return static_cast<dexkit::schema::AnnotationEncodeValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const dexkit::schema::EncodeValueByte *value_as_EncodeValueByte() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueByte ? static_cast<const dexkit::schema::EncodeValueByte *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueShort *value_as_EncodeValueShort() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueShort ? static_cast<const dexkit::schema::EncodeValueShort *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueChar *value_as_EncodeValueChar() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueChar ? static_cast<const dexkit::schema::EncodeValueChar *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueInt *value_as_EncodeValueInt() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueInt ? static_cast<const dexkit::schema::EncodeValueInt *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueLong *value_as_EncodeValueLong() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueLong ? static_cast<const dexkit::schema::EncodeValueLong *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueFloat *value_as_EncodeValueFloat() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueFloat ? static_cast<const dexkit::schema::EncodeValueFloat *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueDouble *value_as_EncodeValueDouble() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueDouble ? static_cast<const dexkit::schema::EncodeValueDouble *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueString *value_as_EncodeValueString() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueString ? static_cast<const dexkit::schema::EncodeValueString *>(value()) : nullptr;
  }
  const dexkit::schema::ClassMeta *value_as_ClassMeta() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::ClassMeta ? static_cast<const dexkit::schema::ClassMeta *>(value()) : nullptr;
  }
  const dexkit::schema::MethodMeta *value_as_MethodMeta() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::MethodMeta ? static_cast<const dexkit::schema::MethodMeta *>(value()) : nullptr;
  }
  const dexkit::schema::FieldMeta *value_as_FieldMeta() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::FieldMeta ? static_cast<const dexkit::schema::FieldMeta *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationEncodeArray *value_as_AnnotationEncodeArray() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::AnnotationEncodeArray ? static_cast<const dexkit::schema::AnnotationEncodeArray *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationMeta *value_as_AnnotationMeta() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::AnnotationMeta ? static_cast<const dexkit::schema::AnnotationMeta *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueNull *value_as_EncodeValueNull() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueNull ? static_cast<const dexkit::schema::EncodeValueNull *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueBoolean *value_as_EncodeValueBoolean() const {
    return value_type() == dexkit::schema::AnnotationEncodeValue::EncodeValueBoolean ? static_cast<const dexkit::schema::EncodeValueBoolean *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnnotationEncodeValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dexkit::schema::EncodeValueByte *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueByte>() const {
  return value_as_EncodeValueByte();
}

template<> inline const dexkit::schema::EncodeValueShort *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueShort>() const {
  return value_as_EncodeValueShort();
}

template<> inline const dexkit::schema::EncodeValueChar *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueChar>() const {
  return value_as_EncodeValueChar();
}

template<> inline const dexkit::schema::EncodeValueInt *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueInt>() const {
  return value_as_EncodeValueInt();
}

template<> inline const dexkit::schema::EncodeValueLong *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueLong>() const {
  return value_as_EncodeValueLong();
}

template<> inline const dexkit::schema::EncodeValueFloat *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueFloat>() const {
  return value_as_EncodeValueFloat();
}

template<> inline const dexkit::schema::EncodeValueDouble *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueDouble>() const {
  return value_as_EncodeValueDouble();
}

template<> inline const dexkit::schema::EncodeValueString *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueString>() const {
  return value_as_EncodeValueString();
}

template<> inline const dexkit::schema::ClassMeta *AnnotationEncodeValueMeta::value_as<dexkit::schema::ClassMeta>() const {
  return value_as_ClassMeta();
}

template<> inline const dexkit::schema::MethodMeta *AnnotationEncodeValueMeta::value_as<dexkit::schema::MethodMeta>() const {
  return value_as_MethodMeta();
}

template<> inline const dexkit::schema::FieldMeta *AnnotationEncodeValueMeta::value_as<dexkit::schema::FieldMeta>() const {
  return value_as_FieldMeta();
}

template<> inline const dexkit::schema::AnnotationEncodeArray *AnnotationEncodeValueMeta::value_as<dexkit::schema::AnnotationEncodeArray>() const {
  return value_as_AnnotationEncodeArray();
}

template<> inline const dexkit::schema::AnnotationMeta *AnnotationEncodeValueMeta::value_as<dexkit::schema::AnnotationMeta>() const {
  return value_as_AnnotationMeta();
}

template<> inline const dexkit::schema::EncodeValueNull *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueNull>() const {
  return value_as_EncodeValueNull();
}

template<> inline const dexkit::schema::EncodeValueBoolean *AnnotationEncodeValueMeta::value_as<dexkit::schema::EncodeValueBoolean>() const {
  return value_as_EncodeValueBoolean();
}

struct AnnotationEncodeValueMetaBuilder {
  typedef AnnotationEncodeValueMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(dexkit::schema::AnnotationEncodeValueType type) {
    fbb_.AddElement<int8_t>(AnnotationEncodeValueMeta::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_value_type(dexkit::schema::AnnotationEncodeValue value_type) {
    fbb_.AddElement<uint8_t>(AnnotationEncodeValueMeta::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(AnnotationEncodeValueMeta::VT_VALUE, value);
  }
  explicit AnnotationEncodeValueMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationEncodeValueMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationEncodeValueMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationEncodeValueMeta> CreateAnnotationEncodeValueMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    dexkit::schema::AnnotationEncodeValueType type = dexkit::schema::AnnotationEncodeValueType::ByteValue,
    dexkit::schema::AnnotationEncodeValue value_type = dexkit::schema::AnnotationEncodeValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  AnnotationEncodeValueMetaBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct AnnotationEncodeValueMeta::Traits {
  using type = AnnotationEncodeValueMeta;
  static auto constexpr Create = CreateAnnotationEncodeValueMeta;
};

struct AnnotationEncodeArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationEncodeArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct AnnotationEncodeArrayBuilder {
  typedef AnnotationEncodeArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>>> values) {
    fbb_.AddOffset(AnnotationEncodeArray::VT_VALUES, values);
  }
  explicit AnnotationEncodeArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationEncodeArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationEncodeArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationEncodeArray> CreateAnnotationEncodeArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>>> values = 0) {
  AnnotationEncodeArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

struct AnnotationEncodeArray::Traits {
  using type = AnnotationEncodeArray;
  static auto constexpr Create = CreateAnnotationEncodeArray;
};

inline ::flatbuffers::Offset<AnnotationEncodeArray> CreateAnnotationEncodeArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta>>(*values) : 0;
  return dexkit::schema::CreateAnnotationEncodeArray(
      _fbb,
      values__);
}

struct AnnotationElementMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const dexkit::schema::AnnotationEncodeValueMeta *value() const {
    return GetPointer<const dexkit::schema::AnnotationEncodeValueMeta *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementMetaBuilder {
  typedef AnnotationElementMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnnotationElementMeta::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta> value) {
    fbb_.AddOffset(AnnotationElementMeta::VT_VALUE, value);
  }
  explicit AnnotationElementMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementMeta> CreateAnnotationElementMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta> value = 0) {
  AnnotationElementMetaBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AnnotationElementMeta::Traits {
  using type = AnnotationElementMeta;
  static auto constexpr Create = CreateAnnotationElementMeta;
};

inline ::flatbuffers::Offset<AnnotationElementMeta> CreateAnnotationElementMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<dexkit::schema::AnnotationEncodeValueMeta> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return dexkit::schema::CreateAnnotationElementMeta(
      _fbb,
      name__,
      value);
}

struct AnnotationMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEX_ID = 4,
    VT_TYPE_ID = 6,
    VT_TYPE_DESCRIPTOR = 8,
    VT_VISIBILITY = 10,
    VT_ELEMENTS = 12
  };
  uint32_t dex_id() const {
    return GetField<uint32_t>(VT_DEX_ID, 0);
  }
  uint32_t type_id() const {
    return GetField<uint32_t>(VT_TYPE_ID, 0);
  }
  const ::flatbuffers::String *type_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_DESCRIPTOR);
  }
  dexkit::schema::AnnotationVisibilityType visibility() const {
    return static_cast<dexkit::schema::AnnotationVisibilityType>(GetField<int8_t>(VT_VISIBILITY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>> *elements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>> *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TYPE_ID, 4) &&
           VerifyOffset(verifier, VT_TYPE_DESCRIPTOR) &&
           verifier.VerifyString(type_descriptor()) &&
           VerifyField<int8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
};

struct AnnotationMetaBuilder {
  typedef AnnotationMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dex_id(uint32_t dex_id) {
    fbb_.AddElement<uint32_t>(AnnotationMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_type_id(uint32_t type_id) {
    fbb_.AddElement<uint32_t>(AnnotationMeta::VT_TYPE_ID, type_id, 0);
  }
  void add_type_descriptor(::flatbuffers::Offset<::flatbuffers::String> type_descriptor) {
    fbb_.AddOffset(AnnotationMeta::VT_TYPE_DESCRIPTOR, type_descriptor);
  }
  void add_visibility(dexkit::schema::AnnotationVisibilityType visibility) {
    fbb_.AddElement<int8_t>(AnnotationMeta::VT_VISIBILITY, static_cast<int8_t>(visibility), 0);
  }
  void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>>> elements) {
    fbb_.AddOffset(AnnotationMeta::VT_ELEMENTS, elements);
  }
  explicit AnnotationMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dex_id = 0,
    uint32_t type_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type_descriptor = 0,
    dexkit::schema::AnnotationVisibilityType visibility = dexkit::schema::AnnotationVisibilityType::Build,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>>> elements = 0) {
  AnnotationMetaBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_type_descriptor(type_descriptor);
  builder_.add_type_id(type_id);
  builder_.add_dex_id(dex_id);
  builder_.add_visibility(visibility);
  return builder_.Finish();
}

struct AnnotationMeta::Traits {
  using type = AnnotationMeta;
  static auto constexpr Create = CreateAnnotationMeta;
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dex_id = 0,
    uint32_t type_id = 0,
    const char *type_descriptor = nullptr,
    dexkit::schema::AnnotationVisibilityType visibility = dexkit::schema::AnnotationVisibilityType::Build,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>> *elements = nullptr) {
  auto type_descriptor__ = type_descriptor ? _fbb.CreateString(type_descriptor) : 0;
  auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationElementMeta>>(*elements) : 0;
  return dexkit::schema::CreateAnnotationMeta(
      _fbb,
      dex_id,
      type_id,
      type_descriptor__,
      visibility,
      elements__);
}

struct AnnotationMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATIONS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>> *>(VT_ANNOTATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           verifier.VerifyVectorOfTables(annotations()) &&
           verifier.EndTable();
  }
};

struct AnnotationMetaArrayHolderBuilder {
  typedef AnnotationMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>>> annotations) {
    fbb_.AddOffset(AnnotationMetaArrayHolder::VT_ANNOTATIONS, annotations);
  }
  explicit AnnotationMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMetaArrayHolder> CreateAnnotationMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>>> annotations = 0) {
  AnnotationMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_annotations(annotations);
  return builder_.Finish();
}

struct AnnotationMetaArrayHolder::Traits {
  using type = AnnotationMetaArrayHolder;
  static auto constexpr Create = CreateAnnotationMetaArrayHolder;
};

inline ::flatbuffers::Offset<AnnotationMetaArrayHolder> CreateAnnotationMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>> *annotations = nullptr) {
  auto annotations__ = annotations ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationMeta>>(*annotations) : 0;
  return dexkit::schema::CreateAnnotationMetaArrayHolder(
      _fbb,
      annotations__);
}

struct ParametersAnnotationMetaArrayHoler FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParametersAnnotationMetaArrayHolerBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATIONS_ARRAY = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>> *annotations_array() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>> *>(VT_ANNOTATIONS_ARRAY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATIONS_ARRAY) &&
           verifier.VerifyVector(annotations_array()) &&
           verifier.VerifyVectorOfTables(annotations_array()) &&
           verifier.EndTable();
  }
};

struct ParametersAnnotationMetaArrayHolerBuilder {
  typedef ParametersAnnotationMetaArrayHoler Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotations_array(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>>> annotations_array) {
    fbb_.AddOffset(ParametersAnnotationMetaArrayHoler::VT_ANNOTATIONS_ARRAY, annotations_array);
  }
  explicit ParametersAnnotationMetaArrayHolerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParametersAnnotationMetaArrayHoler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParametersAnnotationMetaArrayHoler>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParametersAnnotationMetaArrayHoler> CreateParametersAnnotationMetaArrayHoler(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>>> annotations_array = 0) {
  ParametersAnnotationMetaArrayHolerBuilder builder_(_fbb);
  builder_.add_annotations_array(annotations_array);
  return builder_.Finish();
}

struct ParametersAnnotationMetaArrayHoler::Traits {
  using type = ParametersAnnotationMetaArrayHoler;
  static auto constexpr Create = CreateParametersAnnotationMetaArrayHoler;
};

inline ::flatbuffers::Offset<ParametersAnnotationMetaArrayHoler> CreateParametersAnnotationMetaArrayHolerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>> *annotations_array = nullptr) {
  auto annotations_array__ = annotations_array ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationMetaArrayHolder>>(*annotations_array) : 0;
  return dexkit::schema::CreateParametersAnnotationMetaArrayHoler(
      _fbb,
      annotations_array__);
}

struct BatchClassMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchClassMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_KEY = 4,
    VT_CLASSES = 6
  };
  const ::flatbuffers::String *union_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *>(VT_CLASSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_KEY) &&
           verifier.VerifyString(union_key()) &&
           VerifyOffset(verifier, VT_CLASSES) &&
           verifier.VerifyVector(classes()) &&
           verifier.VerifyVectorOfTables(classes()) &&
           verifier.EndTable();
  }
};

struct BatchClassMetaBuilder {
  typedef BatchClassMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_key(::flatbuffers::Offset<::flatbuffers::String> union_key) {
    fbb_.AddOffset(BatchClassMeta::VT_UNION_KEY, union_key);
  }
  void add_classes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes) {
    fbb_.AddOffset(BatchClassMeta::VT_CLASSES, classes);
  }
  explicit BatchClassMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchClassMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchClassMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchClassMeta> CreateBatchClassMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes = 0) {
  BatchClassMetaBuilder builder_(_fbb);
  builder_.add_classes(classes);
  builder_.add_union_key(union_key);
  return builder_.Finish();
}

struct BatchClassMeta::Traits {
  using type = BatchClassMeta;
  static auto constexpr Create = CreateBatchClassMeta;
};

inline ::flatbuffers::Offset<BatchClassMeta> CreateBatchClassMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_key = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes = nullptr) {
  auto union_key__ = union_key ? _fbb.CreateString(union_key) : 0;
  auto classes__ = classes ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>(*classes) : 0;
  return dexkit::schema::CreateBatchClassMeta(
      _fbb,
      union_key__,
      classes__);
}

struct BatchClassMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchClassMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct BatchClassMetaArrayHolderBuilder {
  typedef BatchClassMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>>> items) {
    fbb_.AddOffset(BatchClassMetaArrayHolder::VT_ITEMS, items);
  }
  explicit BatchClassMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchClassMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchClassMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchClassMetaArrayHolder> CreateBatchClassMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>>> items = 0) {
  BatchClassMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct BatchClassMetaArrayHolder::Traits {
  using type = BatchClassMetaArrayHolder;
  static auto constexpr Create = CreateBatchClassMetaArrayHolder;
};

inline ::flatbuffers::Offset<BatchClassMetaArrayHolder> CreateBatchClassMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::BatchClassMeta>>(*items) : 0;
  return dexkit::schema::CreateBatchClassMetaArrayHolder(
      _fbb,
      items__);
}

struct BatchMethodMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchMethodMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_KEY = 4,
    VT_METHODS = 6
  };
  const ::flatbuffers::String *union_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *>(VT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_KEY) &&
           verifier.VerifyString(union_key()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct BatchMethodMetaBuilder {
  typedef BatchMethodMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_key(::flatbuffers::Offset<::flatbuffers::String> union_key) {
    fbb_.AddOffset(BatchMethodMeta::VT_UNION_KEY, union_key);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods) {
    fbb_.AddOffset(BatchMethodMeta::VT_METHODS, methods);
  }
  explicit BatchMethodMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchMethodMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchMethodMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchMethodMeta> CreateBatchMethodMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods = 0) {
  BatchMethodMetaBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_union_key(union_key);
  return builder_.Finish();
}

struct BatchMethodMeta::Traits {
  using type = BatchMethodMeta;
  static auto constexpr Create = CreateBatchMethodMeta;
};

inline ::flatbuffers::Offset<BatchMethodMeta> CreateBatchMethodMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_key = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods = nullptr) {
  auto union_key__ = union_key ? _fbb.CreateString(union_key) : 0;
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>(*methods) : 0;
  return dexkit::schema::CreateBatchMethodMeta(
      _fbb,
      union_key__,
      methods__);
}

struct BatchMethodMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchMethodMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct BatchMethodMetaArrayHolderBuilder {
  typedef BatchMethodMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>>> items) {
    fbb_.AddOffset(BatchMethodMetaArrayHolder::VT_ITEMS, items);
  }
  explicit BatchMethodMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchMethodMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchMethodMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchMethodMetaArrayHolder> CreateBatchMethodMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>>> items = 0) {
  BatchMethodMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct BatchMethodMetaArrayHolder::Traits {
  using type = BatchMethodMetaArrayHolder;
  static auto constexpr Create = CreateBatchMethodMetaArrayHolder;
};

inline ::flatbuffers::Offset<BatchMethodMetaArrayHolder> CreateBatchMethodMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::BatchMethodMeta>>(*items) : 0;
  return dexkit::schema::CreateBatchMethodMetaArrayHolder(
      _fbb,
      items__);
}

struct UsingFieldMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingFieldMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4,
    VT_USING_TYPE = 6
  };
  const dexkit::schema::FieldMeta *field() const {
    return GetPointer<const dexkit::schema::FieldMeta *>(VT_FIELD);
  }
  dexkit::schema::UsingType using_type() const {
    return static_cast<dexkit::schema::UsingType>(GetField<int8_t>(VT_USING_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           VerifyField<int8_t>(verifier, VT_USING_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct UsingFieldMetaBuilder {
  typedef UsingFieldMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field(::flatbuffers::Offset<dexkit::schema::FieldMeta> field) {
    fbb_.AddOffset(UsingFieldMeta::VT_FIELD, field);
  }
  void add_using_type(dexkit::schema::UsingType using_type) {
    fbb_.AddElement<int8_t>(UsingFieldMeta::VT_USING_TYPE, static_cast<int8_t>(using_type), 0);
  }
  explicit UsingFieldMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingFieldMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingFieldMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingFieldMeta> CreateUsingFieldMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::FieldMeta> field = 0,
    dexkit::schema::UsingType using_type = dexkit::schema::UsingType::Any) {
  UsingFieldMetaBuilder builder_(_fbb);
  builder_.add_field(field);
  builder_.add_using_type(using_type);
  return builder_.Finish();
}

struct UsingFieldMeta::Traits {
  using type = UsingFieldMeta;
  static auto constexpr Create = CreateUsingFieldMeta;
};

struct UsingFieldMetaArrayHolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingFieldMetaArrayHolderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct UsingFieldMetaArrayHolderBuilder {
  typedef UsingFieldMetaArrayHolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>>> items) {
    fbb_.AddOffset(UsingFieldMetaArrayHolder::VT_ITEMS, items);
  }
  explicit UsingFieldMetaArrayHolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingFieldMetaArrayHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingFieldMetaArrayHolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingFieldMetaArrayHolder> CreateUsingFieldMetaArrayHolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>>> items = 0) {
  UsingFieldMetaArrayHolderBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct UsingFieldMetaArrayHolder::Traits {
  using type = UsingFieldMetaArrayHolder;
  static auto constexpr Create = CreateUsingFieldMetaArrayHolder;
};

inline ::flatbuffers::Offset<UsingFieldMetaArrayHolder> CreateUsingFieldMetaArrayHolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::UsingFieldMeta>>(*items) : 0;
  return dexkit::schema::CreateUsingFieldMetaArrayHolder(
      _fbb,
      items__);
}

inline bool VerifyAnnotationEncodeValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationEncodeValue type) {
  switch (type) {
    case AnnotationEncodeValue::NONE: {
      return true;
    }
    case AnnotationEncodeValue::EncodeValueByte: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueShort: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueChar: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueInt: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueLong: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueString: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::ClassMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::ClassMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::MethodMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::MethodMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::FieldMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::FieldMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::AnnotationEncodeArray: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationEncodeArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::AnnotationMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueNull: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueNull *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValue::EncodeValueBoolean: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnnotationEncodeValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationEncodeValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnnotationEncodeValue(
        verifier,  values->Get(i), types->GetEnum<AnnotationEncodeValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema
}  // namespace dexkit

#endif  // FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_
